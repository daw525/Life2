Splint 3.1.1 --- 12 April 2003

../Source/entity.c: (in function log_weights)
../Source/entity.c(9,9): Assignment of double to float:
    weights[i] = (float)1.0 / (1.0 + log((double)i + 2))
  To allow all numeric types to match, use +relaxtypes.
../Source/entity.c: (in function processEntity)
../Source/entity.c(45,25): Initializer block for weights has 1 element, but
                              declared as float [10]: 0.0
  Initializer does not define all elements of a declared array. (Use
  -initallelements to inhibit warning)
../Source/entity.c(96,9): Dangerous comparison involving float types:
                             e->inputTimeTrue < 0.5
  Two real (float, double, or long double) values are compared directly using a
  C primitive. This may produce unexpected results since floating point
  representations are inexact. Instead, compare the difference to FLT_EPSILON
  or DBL_EPSILON. (Use -realcompare to inhibit warning)
../Source/mapping.c: (in function initialisePort)
../Source/mapping.c(14,9): Implicitly only storage p->p (type bool *) not
                              released before assignment: p->p = b
  A memory leak has been detected. Only-qualified storage is not released
  before the last reference to it is lost. (Use -mustfreeonly to inhibit
  warning)
../Source/mapping.c(14,9): Implicitly temp storage b assigned to implicitly
                              only: p->p = b
  Temp storage (associated with a formal parameter) is transferred to a
  non-temporary reference. The storage may be released or new aliases created.
  (Use -temptrans to inhibit warning)
../Source/mapping.c: (in function initialiseMapping)
../Source/mapping.c(33,9): Implicitly only storage m->outputPort.p (type bool
    *) not released before assignment: m->outputPort.p = NULL
../Source/mapping.c(36,13): Implicitly only storage m->inputPorts[].p (type
    bool *) not released before assignment: m->inputPorts[p].p = NULL
../Source/mapping.c(40,20): Function returns with null storage derivable from
                               parameter m->outputPort.p
  A possibly null pointer is reachable from a parameter or global variable that
  is not declared using a /*@null@*/ annotation. (Use -nullstate to inhibit
  warning)
   ../Source/mapping.c(33,27): Storage m->outputPort.p becomes null
../Source/mapping.c(40,20): Function returns with null storage derivable from
                               parameter m->inputPorts[].p
   ../Source/mapping.c(36,34): Storage m->inputPorts[].p becomes null
../Source/mapping.c: (in function addPortToMapping)
../Source/mapping.c(63,13): Storage p->p is kept in one path, but live in
                               another.
  The state of a variable is different depending on which branch is taken. This
  means no annotation can sensibly be applied to the storage. (Use -branchstate
  to inhibit warning)
   ../Source/mapping.c(60,17): Storage p->p becomes kept
../Source/mapping.c(63,13): Clauses exit with p->p referencing kept storage in
    true branch, implicitly only storage in false branch
   ../Source/mapping.c(60,17): Storage p->p becomes kept
../Source/mapping.c(66,13): Implicitly only storage m->outputPort.p (type bool
    *) not released before assignment: m->outputPort.p = p->p
../Source/mapping.c(69,5): Clauses exit with p->p referencing kept storage in
    true branch, implicitly only storage in false branch
   ../Source/mapping.c(66,13): Storage p->p becomes kept
../Source/mapping.c(70,20): Storage p->p reachable from parameter is
                               unqualified (should be implicitly only)
  Storage derivable from a parameter does not match the alias kind expected for
  the formal parameter. (Use -compmempass to inhibit warning)
../Source/region.c: (in function processRegion)
../Source/region.c(17,13): Return value (type bool) ignored:
                              evaluateMapping(...
  Result returned by function call is not used. If this is intended, can cast
  result to (void) to eliminate message. (Use -retvalbool to inhibit warning)
../Source/world.c: (in function run)
../Source/world.c(50,9): Immediate address &testCases[].SET assigned to
    implicitly only: w.regions[0].layers[0].mappings[0].inputPorts[0].p =
    &testCases[iteration].SET
  An immediate address (result of & operator) is transferred inconsistently.
  (Use -immediatetrans to inhibit warning)
../Source/world.c(51,9): Immediate address &testCases[].RESET assigned to
    implicitly only: w.regions[0].layers[1].mappings[0].inputPorts[0].p =
    &testCases[iteration].RESET

Finished checking --- 17 code warnings
